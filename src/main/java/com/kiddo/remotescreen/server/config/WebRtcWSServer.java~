package com.kiddo.remotescreen.server.config;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.kiddo.remotescreen.server.entity.Device;
import com.kiddo.remotescreen.server.service.DeviceService;
import jakarta.websocket.*;
import jakarta.websocket.server.PathParam;
import jakarta.websocket.server.ServerEndpoint;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.text.SimpleDateFormat;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Component
@ServerEndpoint(value = "/auth/webrtc/{deviceId}")
public class WebRtcWSServer {

    private static final Logger log = LoggerFactory.getLogger(WebRtcWSServer.class);

    private static final Map<String, Session> sessionMap = new ConcurrentHashMap<>();
    private static final ObjectMapper mapper = new ObjectMapper()
            .setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"))
            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

    @OnOpen
    public void onOpen(Session session, @PathParam("deviceId") String deviceId) {
        try {
            DeviceService deviceService = SpringContext.getBean(DeviceService.class);

            Device asPcDevice = deviceService.getDeviceById(deviceId);
            if (asPcDevice != null) {
                // ‚úÖ ƒê√¢y l√† thi·∫øt b·ªã PC
                if (!Boolean.TRUE.equals(asPcDevice.getAllowRemote())) {
                    session.close(new CloseReason(CloseReason.CloseCodes.VIOLATED_POLICY, "Remote access disabled"));
                    return;
                }

                sessionMap.put(deviceId, session);
                log.info("‚úÖ PC connected: {}", deviceId);
                return;
            }

            // ‚úÖ ƒê√¢y l√† Android (PixelTest) ‚Üí ki·ªÉm tra xem n√≥ c√≥ ƒë∆∞·ª£c ph√©p kh√¥ng
            for (String pcId : sessionMap.keySet()) {
                Device pc = deviceService.getDeviceById(pcId);
                if (pc != null && deviceId.equals(pc.getConnectedAndroid())) {
                    sessionMap.put(deviceId, session);
                    log.info("‚úÖ Android '{}' connected to PC '{}'", deviceId, pcId);
                    return;
                }
            }

            // ‚ùå Android ch∆∞a ƒë∆∞·ª£c connect-android ho·∫∑c sai
            session.close(new CloseReason(CloseReason.CloseCodes.VIOLATED_POLICY, "Unauthorized Android"));

        } catch (Exception e) {
            log.error("üí• WebSocket onOpen error: {}", e.getMessage(), e);
            try {
                session.close(new CloseReason(CloseReason.CloseCodes.UNEXPECTED_CONDITION, "Internal error"));
            } catch (Exception ignore) {}
        }
    }

    @OnClose
    public void onClose(Session session) {
        String disconnectedId = null;

        try {
            // T√¨m ID b·ªã ng·∫Øt k·∫øt n·ªëi (PC ho·∫∑c Android)
            for (Map.Entry<String, Session> entry : sessionMap.entrySet()) {
                if (entry.getValue().equals(session)) {
                    disconnectedId = entry.getKey();
                    break;
                }
            }

            if (disconnectedId == null) {
                log.warn("üîå Unknown session closed (not found in sessionMap)");
                return;
            }

            sessionMap.remove(disconnectedId);
            log.info("üîå WebSocket closed: {}", disconnectedId);

            DeviceService deviceService = SpringContext.getBean(DeviceService.class);
            List<String> allDeviceIds = deviceService.getAllDeviceIds(); // b·∫°n c·∫ßn th√™m h√†m n√†y

            for (String deviceId : allDeviceIds) {
                Device device = deviceService.getDeviceById(deviceId);
                if (device == null) continue;

                // TH1: Android disconnect (matched as connectedAndroid)
                if (disconnectedId.equals(device.getConnectedAndroid())) {
                    device.setConnectedAndroid(null);
                    deviceService.save(device);
                    log.info("üßπ Android '{}' disconnected ‚Üí cleared from PC '{}'", disconnectedId, deviceId);
                    break;
                }

                // TH2: PC disconnect (matched as deviceId)
                if (disconnectedId.equals(device.getDeviceId()) && device.getConnectedAndroid() != null) {
                    String oldAndroid = device.getConnectedAndroid();
                    device.setConnectedAndroid(null);
                    deviceService.save(device);
                    log.info("üßπ PC '{}' disconnected ‚Üí cleared connectedAndroid '{}'", disconnectedId, oldAndroid);

                    // üîå Ng·∫Øt lu√¥n Android n·∫øu ƒëang gi·ªØ session
                    Session androidSession = sessionMap.get(oldAndroid);
                    if (androidSession != null && androidSession.isOpen()) {
                        androidSession.close(new CloseReason(
                                CloseReason.CloseCodes.NORMAL_CLOSURE,
                                "PC disconnected"
                        ));
                        sessionMap.remove(oldAndroid);
                        log.info("üîå Android '{}' forcibly disconnected due to PC '{}'", oldAndroid, disconnectedId);
                    }
                }
            }

        } catch (Exception e) {
            log.error("üí• Error in @OnClose '{}': {}", disconnectedId, e.getMessage(), e);
        }
    }


    @OnError
    public void onError(Session session, Throwable error) {
        String disconnectedId = null;

        try {
            // X√°c ƒë·ªãnh ID c·ªßa session g·∫∑p l·ªói
            for (Map.Entry<String, Session> entry : sessionMap.entrySet()) {
                if (entry.getValue().equals(session)) {
                    disconnectedId = entry.getKey();
                    break;
                }
            }

            log.error("üí• WebSocket error [{}]: {}", disconnectedId != null ? disconnectedId : session.getId(), error.getMessage(), error);

            if (disconnectedId == null) {
                return;
            }

            sessionMap.remove(disconnectedId);
            log.warn("‚ùå Removed session after error for '{}'", disconnectedId);

            DeviceService deviceService = SpringContext.getBean(DeviceService.class);
            List<String> allDeviceIds = deviceService.getAllDeviceIds(); // same as used in @OnClose

            for (String deviceId : allDeviceIds) {
                Device device = deviceService.getDeviceById(deviceId);
                if (device == null) continue;

                // Android b·ªã l·ªói ‚Üí remove kh·ªèi PC
                if (disconnectedId.equals(device.getConnectedAndroid())) {
                    device.setConnectedAndroid(null);
                    deviceService.save(device);
                    log.info("üßπ Android '{}' error-disconnected ‚Üí cleared from PC '{}'", disconnectedId, deviceId);
                    break;
                }

                // PC b·ªã l·ªói ‚Üí remove Android ƒë√£ g√°n
                if (disconnectedId.equals(device.getDeviceId()) && device.getConnectedAndroid() != null) {
                    String oldAndroid = device.getConnectedAndroid();
                    device.setConnectedAndroid(null);
                    deviceService.save(device);
                    log.info("üßπ PC '{}' error-disconnected ‚Üí cleared connectedAndroid '{}'", disconnectedId, oldAndroid);
                    
                    Session androidSession = sessionMap.get(oldAndroid);
                    if (androidSession != null && androidSession.isOpen()) {
                        androidSession.close(new CloseReason(
                                CloseReason.CloseCodes.NORMAL_CLOSURE,
                                "PC disconnected due to error"
                        ));
                        sessionMap.remove(oldAndroid);
                        log.info("üîå Android '{}' forcibly disconnected due to PC error '{}'", oldAndroid, disconnectedId);
                    }
                    break;
                }
            }

            // Close session safely
            if (session.isOpen()) {
                session.close(new CloseReason(CloseReason.CloseCodes.UNEXPECTED_CONDITION, "WebSocket error"));
            }

        } catch (Exception e) {
            log.error("üí• Error during @OnError cleanup for '{}': {}", disconnectedId, e.getMessage(), e);
        }
    }

    @OnMessage
    public void onMessage(String message, Session session) {
        log.info("üì• Incoming message: {}", message);
        log.info("üìå Current sessionMap: {}", sessionMap.keySet());

        try {
            Map<String, Object> messageMap = mapper.readValue(message, new TypeReference<>() {});
            String type = (String) messageMap.get("type");
            String fromUser = (String) messageMap.get("fromUser");
            String toUser = (String) messageMap.get("toUser");

            Session targetSession = sessionMap.get(toUser);
            if (targetSession == null) {
                log.warn("‚ùå Target session '{}' not found. sessionMap keys: {}", toUser, sessionMap.keySet());
                return;
            }

            Map<String, Object> response = new HashMap<>();
            response.put("type", type);
            response.put("fromUser", fromUser);
            response.put("toUser", toUser);

            switch (type) {
                case "offer", "answer" -> {
                    response.put("sdp", messageMap.get("sdp"));
                    log.info("üîÅ Forwarding {} from {} ‚Üí {}", type, fromUser, toUser);
                }
                case "ice_candidate" -> {
                    response.put("candidate", messageMap.get("candidate"));
                    log.info("‚ùÑÔ∏è Forwarding ICE candidate from {} ‚Üí {}", fromUser, toUser);
                }
                default -> {
                    log.warn("‚ö†Ô∏è Unknown message type: {}", type);
                    return;
                }
            }

            String jsonResponse = mapper.writeValueAsString(response);
            targetSession.getBasicRemote().sendText(jsonResponse);
            log.info("üì§ Sent message to {}: {}", toUser, jsonResponse);

        } catch (Exception e) {
            log.error("üí• Error handling message: {}", message, e);
        }
    }

}
